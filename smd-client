#! /usr/bin/env lua5.1
-- 
-- Released under the terms of GPLv3 or at your option any later version.
-- No warranties.
-- Copyright 2009 Enrico Tassi <gares@fettunta.org>

local PREFIX = '@PREFIX@ '
local MDDIFF
if string.sub(PREFIX,1,1) == '@' then
		MDDIFF = os.getenv('HOME')..'/SYNC/smd/mddiff '
		io.stderr:write('smd-client not installed, assuming mddiff is: ',MDDIFF,'\n')
else
		MDDIFF = PREFIX .. '/bin/mddiff'
end

local queue_max_len = 50

local verbose = false

function log(msg)
	if verbose then
		io.stderr:write(msg,'\n')
	end
end

function log_error(msg)
	io.stderr:write('ERROR: ',msg,'\n')
end

function trace(x)
	if verbose then
		local t = {}
		local n = 2
		while true do
			local d = debug.getinfo(n,"nl")
			if not d or not d.name then break end
			t[#t+1] = d.name ..":".. (d.currentline or "?")
			n=n+1
		end
		io.stderr:write('TRACE: ',table.concat(t," | "),'\n')
	end
	return x
end

function receive(inf,outfile)
	local outf = io.open(outfile,"w")
	if not outf then
			log_error("Unable to open "..outfile.." for writing.")
			log_error('It may be caused by bad directory permissions, '..
				'please check.')
			os.exit(1)
	end

	local line = inf:read("*l")
	local len = tonumber(line:match('^chunk (%d+)'))
	while len > 0 do
		local next_chunk = 16384
		if len < next_chunk then next_chunk = len end
		local data = inf:read(next_chunk)
		len = len - data:len()
		outf:write(data)
	end
	outf:close()
end

function receive_delta(inf)
	local cmds = {}
	local line = ""

	repeat
		line = inf:read("*l")
		if line and line ~= "END" then cmds[#cmds+1] = line end
	until not line or line == "END"
	if line ~= "END" then
		log_error('Unable to receive a complete diff')
		os.exit(1)
	end

	return cmds
end

local mkdir_p_cache = {}

function mkdir_p(path)
	local t = {} 
	for m in path:gmatch('([^/]+)') do t[#t+1] = m end
	table.remove(t,#t)
	local dir = table.concat(t,'/')
	if not mkdir_p_cache[dir] then
		local rc = os.execute('mkdir -p '..dir)
		if rc ~= 0 then
			log_error("Unable to create directory "..dir)
			log_error('It may be caused by bad directory permissions, '..
				'please check.')
			os.exit(1)
		end
		mkdir_p_cache[dir] = true
	end
end

function tmp_for(path,use_tmp)
	local use_tmp = use_tmp or true
	local t = {} 
	for m in path:gmatch('([^/]+)') do t[#t+1] = m end
	local fname = t[#t]
	table.remove(t,#t)
	local i, found = 0, false
	if use_tmp then
		for i=#t,1,-1 do
			if t[i] == 'cur' or t[i] == 'new' then 
				t[i] = 'tmp' 
				found = true
				break
			end
		end
	end
	local newpath
	if not found then
		newpath = path .. '.new'
	else
		t[#t+1] = fname
		newpath = table.concat(t,'/') 
	end
	mkdir_p(newpath)
	while exists(newpath) do newpath = newpath .. 'x' end
	return newpath
end

function sha_file(name)
	local inf = io.popen(MDDIFF .. name)
	local hsha, bsha = inf:read('*a'):match('(%S+) (%S+)') 
	inf:close()
	return hsha, bsha
end

local get_full_email_queue = {}

function process_get_full_email_queue()
	local command = {}
	for _,v in ipairs(get_full_email_queue) do
		command[#command+1] = 'GET ' .. v.name
	end
	command[#command+1] = ''
	io.stdout:write(table.concat(command,'\n'))
	command = nil
	io.stdout:flush()
	local tmp = {}
	for _,v in ipairs(get_full_email_queue) do
		tmp[#tmp+1] = tmp_for(v.name)
		v.tmp = tmp[#tmp]
		receive(io.stdin, tmp[#tmp])
	end
	local inf = io.popen(MDDIFF .. table.concat(tmp,' '))
	tmp = nil
	for _,v in ipairs(get_full_email_queue) do
		local hsha_l, bsha_l = inf:read('*l'):match('^(%S+) (%S+)$') 
		if hsha_l == nil or bsha_l == nil then
			log('mddiff returned less messages')
			error('mddiff incorrect behaviour')
		elseif hsha_l == v.hsha and bsha_l == v.bsha then
			mkdir_p(v.name)
			local rc = os.rename(v.tmp, v.name) 
			if rc then
				log('added '..v.name)
			else
				log_error('Failed to rename '..v.tmp..' to '..v.name)
				log_error('It may be caused by bad directory permissions, please check.')
				os.remove(v.tmp)
				return (trace(false)) -- fail rename tmpfile to actual name
			end
		else
			log_error('The server sent a different email for '..v.name)
			log_error('This problem should be transient, please retry.')
			os.remove(v.tmp)
			return (trace(false)) -- get full email failed, received wrong mail
		end
	end
	inf:close()
	get_full_email_queue = {}
	return (trace(true)) -- get full email OK
end

function get_full_email(name,hsha,bsha)
	get_full_email_queue[#get_full_email_queue+1] = {
		name = name;
		hsha = hsha;
		bsha = bsha;
	}
	return true
end

function exists(name)
	local f = io.open(name,'r')
	if f ~= nil then
		f:close()
		return true
	else
		return false		
	end
end

function exists_and_sha(name)
	if exists(name) then
		local h, b = sha_file(name)
		return true, h, b
	else
		return false
	end
end

function merge_mail(header,body,target)
	local h = io.open(header,"r")
	local b = io.open(body,"r")
	local t = io.open(target,"w")
	local l
	while true do
		l = h:read("*l")
		if l and l ~= "" then t:write(l,'\n') else break end
	end
	while true do
		l = b:read("*l")
		if not l or l == "" then break end
	end
	t:write('\n')
	while true do
		l = b:read("*l")
		if l then t:write(l,'\n') else break end
	end
	h:close()
	b:close()
	t:close()
end

function execute_add(cmd)
	local name, hsha, bsha = cmd:match('^ADD (%S+) (%S+) (%S+)$')
	local ex, hsha_l, bsha_l = exists_and_sha(name)
	if ex then
		if hsha == hsha_l and bsha == bsha_l then
			log('skipping '..name..' already there')
			return (trace(true)) -- skipping add since already there
		else
			log_error('Failed to add '..name..' since a file with the same name')
			log_error('exists but its content is different.')
			log_error('To fix this problem you should rename '..name)
			log_error('Executing `mv '..name..' '..tmp_for(name,false)..'` should work.')
			return (trace(false)) -- skipping add since already there but !=
		end
	end
	return (get_full_email(name,hsha,bsha))
end

function execute_delete(cmd)
	local name, hsha, bsha = cmd:match('^DELETE (%S+) (%S+) (%S+)$')
	local ex, hsha_l, bsha_l = exists_and_sha(name)
	if ex then
		if hsha == hsha_l and bsha == bsha_l then
			local rc = os.remove(name) 
			if rc then
				log('deleted '..name)
				return (trace(true)) -- removed successfully
			else
				log_error('Deletion of '..name..' failed.')
				log_error('It may be caused by bad directory permissions, please check.')
				return (trace(false)) -- os.remove failed
			end
		else
			log_error('Failed to delete '..name..' since the local copy of it has')
			log_error('modifications.')
			log_error('To fix this problem you have two options:')
			log_error('- delete '..name..' by hand')
			log_error('- run smd-push so that this file is added to the remote mailbox')
			return (trace(false)) -- remove fails since local file is !=
		end
	end
	log('already deleted '..name)
	return (trace(true)) -- already removed
end

function execute_copy(cmd)
	local name_src, hsha, bsha, name_tgt = 
		cmd:match('^COPY (%S+) (%S+) (%S+) TO (%S+)$')
	local ex_src, hsha_src, bsha_src = exists_and_sha(name_src)
	local ex_tgt, hsha_tgt, bsha_tgt = exists_and_sha(name_tgt)
	if ex_src and ex_tgt then
		if hsha_src == hsha_tgt and bsha_src == bsha_tgt then
			log('skipping copy of '..name_src..' to '..name_tgt)
			return (trace(true)) -- skip copy, already there
		else
			log_error('Failed to copy '..name_src..' to '..name_tgt)
			log_error('The destination file already exists but its content differs.')
			log_error('To fix this problem you have two options:')
			log_error('- rename '..name_tgt..' by hand so that '..name_src..' can be')
			log_error('  copied without replacing it.')
			log_error('  Executing `mv '..name_tgt..' '..
				tmp_for(name_tgt,false)..'` should work.')
			log_error('- run smd-push so that your changes to '..name_tgt..' are')
			log_error('  propagated to the remote mailbox')
			return (trace(false)) -- fail copy, already there but !=
		end
	elseif ex_src and not ex_tgt then
		if hsha_src == hsha and bsha_src == bsha then
				log('copy '..name_src..' to '..name_tgt)
				mkdir_p(name_tgt)
				local ok = os.execute('cp '..name_src..' '..name_tgt)
				if ok == 0 then 
					return (trace(true)) -- copy successful
				else 
					log('copy '..name_src..' to '..name_tgt..' failed')
					log_error('Failed to copy '..name_src..' to '..name_tgt)
					log_error('It may be caused by bad directory permissions, '..
						'please check.')
					return (trace(false)) -- copy failed (cp command failed)
				end
		else
				-- sub-optimal, we may reuse body or header 
				return (get_full_email(name_tgt,hsha,bsha))
		end
	elseif not ex_src and ex_tgt then
		if hsha == hsha_tgt and bsha == bsha_tgt then
			log('skipping copy of non existent '..name_src..' to '..
				name_tgt ..' since target already there')
			return (trace(true)) -- skip copy, already there (only the copy)
		else
			log_error('Failed to copy '..name_src..' to '..name_tgt)
			log_error('The source file has been locally removed.')
			log_error('The destination file already exists but its content differs.')
			log_error('To fix this problem you have two options:')
			log_error('- rename '..name_tgt..' by hand so that '..name_src..' can be')
			log_error('  copied without replacing it.')
			log_error('  Executing `mv '..name_tgt..' '..
				tmp_for(name_tgt,false)..'` should work.')
			log_error('- run smd-push so that your changes to '..name_tgt..' are')
			log_error('  propagated to the remote mailbox')
			return (trace(false)) -- skip copy, already there and !=, no source
		end
	else
		log('add '..name_tgt..' as a copy of the not existing '..name_src)
		return (get_full_email(name_tgt,hsha,bsha))
	end
end

function get_header_and_merge(name,hsha,bsha)
	local tmpfile = tmp_for(name)
	io.stdout:write('GETHEADER '..name..'\n')
	io.stdout:flush()
	receive(io.stdin, tmpfile)
	local hsha_l, _ = sha_file(tmpfile)
	if hsha_l == hsha then
		local tmpfile1 = tmp_for(name)
		merge_mail(tmpfile,name,tmpfile1)
		os.remove(tmpfile)
		os.rename(tmpfile1, name)
		log('changed header of '..name)
		return (trace(true)) -- get header OK
	else
		os.remove(tmpfile)
		log_error('The server sent a different email header for '..name)
		log_error('This problem should be transient, please retry.')
		return (trace(false)) -- get header fails, got a different header
	end
end

function execute_replaceheader(cmd)
	local name, hsha, bsha, hsha_new = 
		cmd:match('^REPLACEHEADER (%S+) (%S+) (%S+) WITH (%S+)$')
	if exists(name) then
		local hsha_l, bsha_l = sha_file(name)
		if hsha == hsha_l and bsha == bsha_l then
			return (get_header_and_merge(name,hsha_new,bsha))
		elseif hsha_l == hsha_new and bsha == bsha_l then
			log('header already changed for '..name)
			return (trace(true)) -- replace header ok, already changend
		else
			log_error('Failed to replace '..name..' header since it has local')
			log_error(' modifications.')
			log_error('To fix this problem you should rename '..name)
			log_error('Executing `mv '..name..' '..tmp_for(name,false)..'` should work.')
			return (trace(false)) -- replace header fails, local header !=
		end
	else
		log('added '..name)
		return (get_full_email(namename,hsha_new,bsha))
	end
end

function execute(cmd)
	local opcode = cmd:match('^(%S+)')

	    if opcode == "ADD"           then return (execute_add(cmd))
	elseif opcode == "DELETE"        then return (execute_delete(cmd))
	elseif opcode == "COPY"          then return (execute_copy(cmd))
	elseif opcode == "REPLACEHEADER" then return (execute_replaceheader(cmd))


	elseif opcode == "REPLACE" then
		local name1, hsha1, bsha1, name2, hsha2, bsha2 = 
		   cmd:match('^REPLACE (%S+) (%S+) (%S+) WITH (%S+) (%S+) (%S+)$')
		log_error('REPLACE command not implement, sorry')
		return (trace(false))

	else
		error('Unknown opcode '..opcode)
	end
end

function process_pending_queue()
	local rc = process_get_full_email_queue()
	if not rc then
		log('error getting full email')
		io.stdout:write('ABORT\n')
		io.stdout:flush()
		os.exit(1)
	end
end

-- ============================= MAIN =====================================

function main()
	if arg[1] == '-v' then
		verbose = true
	end
	
	local commands = receive_delta(io.stdin)
	log('delta received')
	for i,cmd in ipairs(commands) do
		local rc = execute(cmd)
		if not rc then
			log('error executing command '..i..": "..cmd)
			io.stdout:write('ABORT\n')
			io.stdout:flush()
			os.exit(1)
		end
		if #get_full_email_queue > queue_max_len then
				process_pending_queue()
		end
	end
	process_pending_queue()
	
	log('committing')
	io.stdout:write('COMMIT\n')
	io.stdout:flush()
	os.exit(0)
end

-- strict access to the global environment
setmetatable(_G,{
	__newindex = function (t,k,v)
		local d = debug.getinfo(2,"nl")
		error((d.name or '?')..': '..(d.currentline or '?')..
			' :attempt to create new global '..k)
	end;
	__index = function(t,k)
		local d = debug.getinfo(2,"nl")
		error((d.name or '?')..': '..(d.currentline or '?')..
			' :attempt to read undefined global '..k)
	end;
})

xpcall(main,function(msg)
	log_error(tostring(msg))
	os.exit(1)
end)

-- vim:set ts=4:
