#! /usr/bin/env lua5.1
-- 
-- Released under the terms of GPLv3 or at your option any later version.
-- No warranties.
-- Copyright 2009 Enrico Tassi <gares@fettunta.org>

local PREFIX = '@PREFIX@'
local MDDIFF
if string.sub(PREFIX,1,1) == '@' then
		MDDIFF = os.getenv('HOME')..'/SYNC/syncmaildir/mddiff '
		io.stderr:write('smd-server not installed, assuming mddiff is: ',MDDIFF,'\n')
else
		MDDIFF = PREFIX .. '/bin/mddiff '
end

local PROTOCOL_VERSION="1.0"

local verbose = false

function log(msg)
	if verbose then
		io.stderr:write(msg,'\n')
	end
end

function log_error(msg)
	io.stderr:write('ERROR: ',msg,'\n')
end

function transmit(out, path, what)
	what = what or "all"
	local f = assert(io.open(path,"r"))
	local size = assert(f:seek("end"))
	f:seek("set")

	if what == "header" then
		local line
		local header = {}
		size = 0
		while line ~= "" do
			line = assert(f:read("*l"))
			header[#header+1] = line
			header[#header+1] = "\n"
			size = size + 1 + string.len(line)
		end
		f:close()
		out:write("chunk " .. size .. "\n")
		out:write(unpack(header))
		out:flush()
		return
	end

	if what == "body" then
		local line
		while line ~= "" do
			line = assert(f:read("*l"))
			size = size -1 -string.len(line)
		end
	end

	out:write("chunk " .. size .. "\n")
	while true do
		local data = f:read(16384)
		if data == nil then break end
		out:write(data)
	end
	out:flush()

	f:close()
end

function dbfile_name(endpoint, mailboxes)
	local HOME = os.getenv('HOME')
	os.execute('mkdir -p '..HOME..'/.smd')
	local dbfile = HOME..'/.smd/' ..endpoint:gsub('/$',''):gsub('/','_').. '__' 
		..table.concat(mailboxes,'__'):gsub('/$',''):gsub('/','_').. '.db.txt'
	return dbfile
end

function touch(f)
	local h = io.open(f,'r')
	if h == nil then
		h = io.open(f,'w')
		if h == nil then
			log_error('Unable to touch '..f)
			os.exit(1)
		else
			h:close()
		end
	else
		h:close()
	end
end

function handshake(dbfile)
	-- send the protocol version and the dbfile sha1 sum
	io.write('protocol ',PROTOCOL_VERSION,'\n')
	touch(dbfile)
	local inf = io.popen('sha1sum '.. dbfile,'r')
	local db_sha = inf:read('*a'):match('^(%S+)')
	io.write('dbfile ',db_sha,'\n')
	io.flush()

	-- check protocol version and dbfile sha
	local protocol = io.read('*l'):match('^protocol (.+)$')
	if protocol ~= PROTOCOL_VERSION then
		log_error('Wrong protocol version.')
		log_error('The same version of syncmaildir must be user on '..
			'both endpoints')
		os.exit(1)
	end
	local sha = io.read('*l'):match('^dbfile (%S+)$')
	if sha ~= db_sha then
		log_error('Local dbfile and remote db file differ.')
		log_error('Remove both files and push/pull again.')
		os.exit(1)
	end
end

-- ============================= MAIN =====================================

function main()
	if arg[1] == '-v' then
		verbose = true
		table.remove(arg,1)
	end
	
	if #arg < 2 then
		io.stderr:write([[
Usage: ]]..arg[0]..[[ [-v] endpointname mailboxes...]],'\n')
		os.exit(1)
	end
	
	local endpoint = arg[1]
	table.remove(arg,1)
	local dbfile = dbfile_name(endpoint, arg)
	local xdelta = dbfile .. '.xdelta'
	local newdb = dbfile .. '.new'

	local database_opt = '--db-file '.. dbfile
	local mailbox_opt = table.concat(arg,' ')

	-- we check the protocol version and dbfile fingerprint
	handshake(dbfile)
	
	-- run mddiff and send the output to the client
	local mddiff = MDDIFF..database_opt..' '..mailbox_opt
	log('checking '.. MDDIFF)
	if os.execute('test -e '..MDDIFF) ~= 0 then
		log_error('Cannot execute '..MDDIFF,'\n')
		os.exit(4)
	end
	log('calling '.. mddiff)
	local r = io.popen(mddiff,"r")
	local sent = 0
	while true do
		local l = r:read("*l")
		if l ~= nil then
			sent = sent + 1
			io.write(l,'\n')
		else
			break
		end
	end
	r:close()
	log('done\n')
	
	
	-- end the first phase, now the client should
	-- apply the diff eventually asking for the transmission
	-- of some data
	io.write('END\n')
	io.flush()
	
	-- process client commands
	while true do
		local l = io.read('*l')
		if l == nil then 
			-- end of input stream, client is dead
			log_error('Communication with client died unexpectedly\n')
			os.exit(3)
		end
		if l:match('^COMMIT$') then
			-- the client applied the diff, the new mailbox
			-- fingerprint should be used for the next sync
			local rc
			rc = os.execute('xdelta delta '..dbfile..' '..newdb..' '..xdelta)
			if rc ~= 0 and rc ~= 256 then
				log_error('Failed running `xdelta delta` on db file: '..rc)
				os.exit(1)
			end
			transmit(io.stdout, xdelta, "all")
			os.remove(xdelta)
		elseif l:match('^DONE$') then
			os.rename(newdb, dbfile) 
			os.exit(0)
		elseif l:match('^ABORT$') then
			-- the client failed in applying the diff
			log_error('Client aborted, removing '..dbfile..'.new\n')
			os.remove(dbfile..".new")
			os.exit(2)
		elseif l:match('^GET ') then
			local path = l:match('^GET ([^%s]+)$')
			transmit(io.stdout, path, "all")
		elseif l:match('^GETHEADER ') then
			local path = l:match('^GETHEADER ([^%s]+)$')
			transmit(io.stdout, path, "header")
		elseif l:match('^GETBODY ') then
			local path = l:match('^GETBODY ([^%s]+)$')
			transmit(io.stdout, path, "body")
		else
			-- protocol error
			log_error('Invalid command '..l..'\n')
			os.exit(1)
		end
	end
end

-- strict access to the global environment
setmetatable(_G,{
	__newindex = function (t,k,v)
		local d = debug.getinfo(2,"nl")
		error((d.name or '?')..': '..(d.currentline or '?')..
			' :attempt to create new global '..k)
	end;
	__index = function(t,k)
		local d = debug.getinfo(2,"nl")
		error((d.name or '?')..': '..(d.currentline or '?')..
			' :attempt to read undefined global '..k)
	end;
})

xpcall(main,function(msg)
	log_error(tostring(msg))
	os.exit(1)
end)

-- vim:set ts=4:
